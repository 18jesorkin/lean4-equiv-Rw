import Tactic.translateF.replace_R
import Tactic.translateF.let_func

def R : Nat → Nat → Prop := fun n₁ n₂ => ∃ m, n₁ % m = n₂ % m ∧ m = 0

-- Setoid instance here:
instance R_Setoid : Setoid Nat :=
  { r := R
    iseqv :=
      { refl :=
          by
          unfold R
          aesop
        symm :=
          by
          unfold R
          aesop
        trans :=
          by
          unfold R
          aesop
                }
                  }

--User-given:
-- @[map₂]
def add_resp : ∀ ⦃a₁ a₂ : Nat⦄, R a₁ a₂ → ∀ ⦃b₁ b₂ : Nat⦄, R b₁ b₂ → R (Nat.add a₁ b₁) (Nat.add a₂ b₂)
  :=
  by
  unfold R
  intro a₁ a₂ h1 b₁ b₂ h2
  simp only [exists_eq_right, Nat.mod_zero] at *
  aesop

-- Autogenerated from "@[map₂]" tag:
def add'
  := Quotient.map₂ (@Nat.add) (@add_resp)
def add'_mk : (x y : Nat) → ⟦Nat.add x y⟧ = @add' ⟦x⟧ ⟦y⟧
  := fun x y => (Quotient.map₂_mk (@Nat.add) (@add_resp) x y).symm


example : (a b c : Nat) → (R a a) ∧ (R a b → R b a) ∧ (R a b → R b c → R a c) :=
  by
  intro a b c
  /-
  repeat any_goals apply And.intro
  all_goals unfold R ; aesop
  -/
  replace_R R R_Setoid
  grind

example : (x y : Nat) → R x y →  R (x.add (x.add (x.add (x.add y)))) (y.add (y.add (y.add (y.add x)))) :=
  by
  /-
  intro x y xRy
  repeat any_goals apply add_resp
  all_goals unfold R at * ; aesop
  -/
  replace_R R R_Setoid
  simp only [add'_mk]
  grind








--Before:   resp_list = [⟨map₂, Nat.add, add_resp⟩]
-- @[map₂]
def mul_resp :  ∀ ⦃a₁ a₂ : ℕ⦄, R a₁ a₂ → ∀ ⦃b₁ b₂ : ℕ⦄, R b₁ b₂ → R (a₁.mul b₁) (a₂.mul b₂)
  := by unfold R ; aesop
--After:    resp_list = [⟨map₂, Nat.add, add_resp⟩, ⟨map₂, Nat.mul, mul_resp⟩]

lemma test (x_R_y : R x y) : R (3 * (1 + (7 + x) + 5)) ((1 + 7 + y + 5) * 3)   :=
  by
  simp_rw [HAdd.hAdd, Add.add, HMul.hMul, Mul.mul]


  translateF R R_Setoid

  -- translateF R R_Setoid resp_list
  replace_R R R_Setoid

  -- For ⟨tag, func, func_resp⟩ in resp_list:
    -- let_func tag func func_resp
  let_map₂ Nat.add add_resp
  let_map₂ Nat.mul mul_resp
  -- simp_list := []
  -- For ⟨tag, func, func_resp⟩ in resp_list:
    -- simp_list := simp_list ++ [← func.appendAfter "_eq"]
  -- evalTactic (← tactic | simp only simp_list at *)
  simp only [← Nat.add_eq, ← Nat.mul_eq] at *
  --simp_rw [← Nat.add_eq, ← Nat.mul_eq] at *

  -- For ⟨tag, func, func_resp⟩ in resp_list:
    -- evalTactic (← tactic | clear (func.appendAfter "_eq"))
  clear Nat.add_eq
  clear Nat.mul_eq

  rewrite [x_R_y]

  -- translateB R R_Setoid resp_list
  let_map₂ Nat.add add_resp
  let_map₂ Nat.mul mul_resp
  simp only [Nat.add_eq, Nat.mul_eq] at *
  clear Nat.add_eq
  clear Nat.mul_eq
  simp only [Quotient.eq, R_Setoid] at *

  suffices eq : (Nat.mul 3 ((Nat.add 1 (Nat.add 7 y)).add 5)) = ((((Nat.add 1 7).add y).add 5).mul 3)
    by
    rewrite [eq] ; clear eq
    apply R_Setoid.iseqv.refl
  grind


--Problems:
  -- Don't know how to automate "simp only [← Nat.add_eq, ← Nat.mul_eq] at *" tactic from respList
  -- Don't know how to how to make mutable "respList" datatype:
    -- Want it to be list of triples ⟨tag, func, func_resp⟩ that tell what func's need to be lifted
    -- then make equality proof (based on tag) then use simp only (after constructing appropriate bit of syntax)



lemma test2 (x_R_y : R x y) (h0 : R (3 + (1 * (7 + x) * 5)) ((1 + 7 * y + 5) * 3)) : R (3 * (1 + (7 + x) + 5)) ((1 + 7 + y + 5) * 3)   :=
  by
  simp_rw [HAdd.hAdd, Add.add, HMul.hMul, Mul.mul] at *
  translateF R R_Setoid ⟨Tag.map₂, Nat.add, add_resp⟩ ⟨Tag.map₂, Nat.mul, mul_resp⟩
  sorry
